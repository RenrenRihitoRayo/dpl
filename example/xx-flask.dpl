&use {std/other/flask.py}
&use {std/text_io.py}
-- Using flask!
   flask is not in requirements.txt
   and thus thats why its in std/other
   This is a simple reactive website written in my
   programming language --

flask:app()

# this is the index, the home of the website
fn home() (flask:route("/"))
    string home new_line
        "<style> body { background-color: grey;  } </style>"
        "<meta name='viewport' content='width=device-width, initial-scale=175%'>"
        "<h1>Darren's Basic Flask Website using DPL 2.0.0</h1><br>"
        "<form action='/test'"
              "method='post'"
              "autocomplete='off'"
              "style='height: 50%; display: flex; justify-content: center; align-items: center;'>"
            "Text: <input name='text' required>"
            "<input type='submit' value='Do stuff'>"
        "</form>"
	"<script>"
	"document.getElementById('text').focus()"
	"</script>
    end
    return :home
end

# The route to display the text we gave earlier
# we dont use files here
# since we have dynamic parts
# in the future itll have templates but not now
fn display_text() (flask:route("/test", [! "GET", "POST"]))
    switch :request.method
        case POST
            set str = :request.form.text
            string template new_line
                "<!DOCTYPE html>"
                "<style> body { background-color: grey; height: 90%; display: flex; justify-content: center; align-items: center; } .text { color: orange; display: inline-block; } </style>"
                '<meta name="viewport" content="width=device-width, initial-scale=1">'
                '<h1> You entered <br><p class="text">${?str}</p><br> :D </h1>'
                "<script> setTimeout(() => { window.location.href = '/' }, 1000); </script>"
            end
            return :template
        end
        case GET
            return "<!DOCTYPE html><style> body { background-color: grey; } </style><meta name='viewport' content='width=device-width, initial-scale=175%'>Submit a post request first!"
        end
        default
            return 'INVALID METHOD: ${request.method}'
        end
    end
end

flask:run_app()
